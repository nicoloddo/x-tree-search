# Introduction

The x-tree-search library provides a flexible system for defining propositions and inferences about nodes in a tree-based structure. Given the framework you can then explain any decision made by the algorithm in an interactive argumentative way.

# Usage Example: MiniMax Tree Search

Here's an example of how to use the Argumentation Framework API to represent a minimax tree search reasoning.
Suppose to have a MiniMax algorithm that gives scores to the leaf nodes and backpropagates the score of the best or worst child depending on if the maximizing or minimizing player is playing.

To argumentatively explain a decision made by our minimax, we have to define where do the adjectives "best" and "worst" come from for a node.
1. Thus, we declare a "score" adjective, linked to the node.score parameter.
2. Then we provide an explanation to why a node has a specific score.
3. This includes explaining what a leaf is,
4. And explaining how to choose the child from which the score has been backpropagated.
5. We then define what does it mean for a node to have a better score,
6. And finally define the "best" and "worst" adjectives.

```python
knowledgebase = ArgumentationFramework()

# Define "score" adjective
knowledgebase.add_adjective( 
    PointerAdjective("score",
        definition = "node.score",

        explanation = ConditionalExplanation(
            condition = If("leaf"),
            explanation_if_true = Assumption("Leaf nodes have scores from the evaluation function"),
            explanation_if_false = CompositeExplanation(
                Assumption("Internal nodes have scores from children"),
                Possession("backtracing child"))
        ))
)

# Define "leaf" adjective
knowledgebase.add_adjective( 
    BooleanAdjective("leaf",
        definition = "node.is_leaf")
)

# Define "opponent player turn" adjective
knowledgebase.add_adjective(
    BooleanAdjective("opponent player turn",
        definition = "not node.maximizing_player_turn")
)

# Define "backtracing child" adjective
knowledgebase.add_adjective( 
    PointerAdjective("backtracing child",
        definition = "node.score_child",
        explanation = ConditionalExplanation(
            condition = If("opponent player turn"),
            explanation_if_true = CompositeExplanation(
                Assumption("We assume the opponent will do their best move."),
                Possession("backtracing child", "worst")),
            explanation_if_false = CompositeExplanation(
                Assumption("On our turn we take the maximum rated move."),
                Possession("backtracing child", "best"))
        ))
)

# Define "better" comparison adjective
knowledgebase.add_adjective(
    ComparisonAdjective("better", "score", ">")
)

knowledgebase.add_adjective( 
    PointerAdjective("siblings",
        definition = "[sibling for sibling in node.parent.children if sibling is not node]")
)

knowledgebase.add_adjective(
    MaxRankAdjective("best", "better", "siblings")
)
knowledgebase.add_adjective(
    MinRankAdjective("worst", "better", "siblings")
)
```

# Modules

```{toctree}
:maxdepth: 2
:caption: Contents:

alphabeta_explainer
```