<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>x-tree-search Argumentation Framework API Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        code {
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
        pre {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 10px;
            margin-bottom: 15px;
        }
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .function { color: #dcdcaa; }
        .class { color: #4ec9b0; }
        .number { color: #b5cea8; }
        .index {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .index ul {
            list-style-type: none;
            padding-left: 0;
        }
        .index ul ul {
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Argumentation Framework API Documentation</h1>

    <div class="index">
        <h2>Index</h2>
        <ul>
            <li><a href="#introduction">1. Introduction</a></li>
            <li><a href="#argumentation-framework">2. ArgumentationFramework</a>
                <ul>
                    <li><a href="#methods">2.1 Methods</a></li>
                    <li><a href="#settings">2.2 Settings</a></li>
                </ul>
            </li>
            <li><a href="#adjectives">3. Adjectives</a>
                <ul>
                    <li><a href="#boolean-adjective">3.1 BooleanAdjective</a></li>
                    <li><a href="#pointer-adjective">3.2 PointerAdjective</a></li>
                    <li><a href="#comparison-adjective">3.3 ComparisonAdjective</a></li>
                    <li><a href="#max-rank-adjective">3.4 MaxRankAdjective</a></li>
                    <li><a href="#min-rank-adjective">3.5 MinRankAdjective</a></li>
                </ul>
            </li>
            <li><a href="#explanations">4. Explanations</a></li>
            <li><a href="#usage-example">5. Usage Example: Minimax Tree with Scoring</a></li>
            <li><a href="#conclusion">6. Conclusion</a></li>
        </ul>
    </div>

    <h2 id="introduction">1. Introduction</h2>
    <p>The Argumentation Framework API provides a flexible system for defining and reasoning about adjectives in a tree-based structure. It's particularly useful for implementing game-theoretic concepts like minimax trees with scoring functions.</p>

    <h2 id="argumentation-framework">2. ArgumentationFramework</h2>
    <p>The main class that manages adjectives and their relationships.</p>
    <pre><code><span class="keyword">knowledgebase</span> = <span class="class">ArgumentationFramework</span>()</code></pre>

    <h3 id="methods">2.1 Methods</h3>

    <h4>add_adjective(adjective: Adjective) -> None</h4>
    <p>Adds an adjective to the framework.</p>
    <ul>
        <li>Parameters:
            <ul>
                <li><code>adjective</code>: The Adjective object to add.</li>
            </ul>
        </li>
        <li>Returns: None</li>
    </ul>

    <h4>rename_adjective(old_name: str, new_name: str) -> None</h4>
    <p>Renames an adjective in the framework.</p>
    <ul>
        <li>Parameters:
            <ul>
                <li><code>old_name</code>: The current name of the adjective.</li>
                <li><code>new_name</code>: The new name for the adjective.</li>
            </ul>
        </li>
        <li>Returns: None</li>
        <li>Raises: ValueError if no adjective with old_name is found.</li>
    </ul>

    <h4>get_adjective(name: str) -> Adjective</h4>
    <p>Retrieves an adjective from the framework.</p>
    <ul>
        <li>Parameters:
            <ul>
                <li><code>name</code>: The name of the adjective to retrieve.</li>
            </ul>
        </li>
        <li>Returns: The Adjective object with the given name.</li>
        <li>Raises: KeyError if no adjective with the given name is found.</li>
    </ul>

    <h4>configure_settings(settings_dict: Dict) -> None</h4>
    <p>Configures settings using a dictionary.</p>
    <ul>
        <li>Parameters:
            <ul>
                <li><code>settings_dict</code>: A dictionary of settings to configure.</li>
            </ul>
        </li>
        <li>Returns: None</li>
    </ul>

    <h3 id="settings">2.2 Settings</h3>
    <p>The ArgumentationFramework class includes settings for controlling explanation depth and verbosity:</p>
    <pre><code>knowledgebase.<span class="keyword">explanation_depth</span> = <span class="number">5</span>
knowledgebase.<span class="keyword">assumptions_verbosity</span> = <span class="string">'minimal'</span>
knowledgebase.<span class="keyword">repeat_explanations</span> = <span class="keyword">False</span></code></pre>

    <h2 id="adjectives">3. Adjectives</h2>
    <p>There are several types of adjectives:</p>

    <h3 id="boolean-adjective">3.1 BooleanAdjective</h3>
    <p>Represents a boolean attribute of a node.</p>
    <pre><code><span class="class">BooleanAdjective</span>(name: str, definition: str = DEFAULT_GETTER, explanation: Explanation = None)</code></pre>
    <ul>
        <li><code>name</code>: The name of the adjective.</li>
        <li><code>definition</code>: The corresponding node attribute (default: DEFAULT_GETTER).</li>
        <li><code>explanation</code>: An explanation for the adjective (optional).</li>
    </ul>

    <h3 id="pointer-adjective">3.2 PointerAdjective</h3>
    <p>Represents an attribute that points to a specific value or node.</p>
    <pre><code><span class="class">PointerAdjective</span>(name: str, definition: str = DEFAULT_GETTER, explanation: Explanation = None)</code></pre>
    <ul>
        <li><code>name</code>: The name of the adjective.</li>
        <li><code>definition</code>: The corresponding node attribute (default: DEFAULT_GETTER).</li>
        <li><code>explanation</code>: An explanation for the adjective (optional).</li>
    </ul>

    <h3 id="comparison-adjective">3.3 ComparisonAdjective</h3>
    <p>Used for comparing nodes based on a specific attribute.</p>
    <pre><code><span class="class">ComparisonAdjective</span>(name: str, property_pointer_adjective_name: str, operator: str)</code></pre>
    <ul>
        <li><code>name</code>: The name of the adjective.</li>
        <li><code>property_pointer_adjective_name</code>: The name of the pointer adjective to use for comparison.</li>
        <li><code>operator</code>: The comparison operator (e.g., ">", "<", "==").</li>
    </ul>

    <h3 id="max-rank-adjective">3.4 MaxRankAdjective</h3>
    <p>Represents the maximum rank in a group based on a comparison.</p>
    <pre><code><span class="class">MaxRankAdjective</span>(name: str, comparison_adjective_name: str, group_pointer_adjective_name: str)</code></pre>
    <ul>
        <li><code>name</code>: The name of the adjective.</li>
        <li><code>comparison_adjective_name</code>: The name of the comparison adjective to use.</li>
        <li><code>group_pointer_adjective_name</code>: The name of the pointer adjective that selects the group to compare with.</li>
    </ul>

    <h3 id="min-rank-adjective">3.5 MinRankAdjective</h3>
    <p>Represents the minimum rank in a group based on a comparison.</p>
    <pre><code><span class="class">MinRankAdjective</span>(name: str, comparison_adjective_name: str, group_pointer_adjective_name: str)</code></pre>
    <ul>
        <li><code>name</code>: The name of the adjective.</li>
        <li><code>comparison_adjective_name</code>: The name of the comparison adjective to use.</li>
        <li><code>group_pointer_adjective_name</code>: The name of the pointer adjective that selects the group to compare with.</li>
    </ul>

<h2 id="explanations">4. Explanations</h2>
    <p>Explanations provide reasoning for adjective assignments. Here are the available explanation classes:</p>

    <h3>Assumption</h3>
    <pre><code><span class="class">Assumption</span>(description: str, definition: str = None)</code></pre>
    <p>A basic explanation based on an assumption.</p>
    <ul>
        <li><code>description</code>: A string describing the assumption.</li>
        <li><code>definition</code>: An optional string providing additional definition (default: None).</li>
    </ul>

    <h3>Possession</h3>
    <pre><code><span class="class">Possession</span>(*args)</code></pre>
    <p>Explains by referring to another adjective's possession.</p>
    <ul>
        <li>Usage:
            <ul>
                <li><code>Possession(adjective_name)</code></li>
                <li><code>Possession(pointer_adjective_name, adjective_name)</code></li>
            </ul>
        </li>
        <li><code>adjective_name</code>: The name of the adjective to explain.</li>
        <li><code>pointer_adjective_name</code>: Optional. The name of the pointer adjective that selects the object.</li>
    </ul>

    <h3>Comparison</h3>
    <pre><code><span class="class">Comparison</span>(comparison_adjective_name: str, node_pointer_adjective_name: str)</code></pre>
    <p>Explains by comparing with another node.</p>
    <ul>
        <li><code>comparison_adjective_name</code>: The name of the comparison adjective.</li>
        <li><code>node_pointer_adjective_name</code>: The name of the pointer adjective that selects the object to compare with.</li>
    </ul>

    <h3>GroupComparison</h3>
    <pre><code><span class="class">GroupComparison</span>(comparison_adjective_name: str, group_pointer_adjective_name: str, positive_implication: bool = True)</code></pre>
    <p>Explains by comparing with a group of nodes.</p>
    <ul>
        <li><code>comparison_adjective_name</code>: The name of the comparison adjective.</li>
        <li><code>group_pointer_adjective_name</code>: The name of the pointer adjective that selects the group to compare with.</li>
        <li><code>positive_implication</code>: Whether the implication is positive (default: True).</li>
    </ul>

    <h3>ConditionalExplanation</h3>
    <pre><code><span class="class">ConditionalExplanation</span>(condition: PossessionCondition, true_explanation: Explanation, false_explanation: Explanation)</code></pre>
    <p>Provides different explanations based on a condition.</p>
    <ul>
        <li><code>condition</code>: A PossessionCondition object that determines which explanation to use.</li>
        <li><code>true_explanation</code>: The explanation to use when the condition is true.</li>
        <li><code>false_explanation</code>: The explanation to use when the condition is false.</li>
    </ul>

    <h3>CompositeExplanation</h3>
    <pre><code><span class="class">CompositeExplanation</span>(*explanations: Explanation)</code></pre>
    <p>Combines multiple explanations.</p>
    <ul>
        <li><code>*explanations</code>: Variable number of Explanation objects to be combined.</li>
    </ul>

    <h3>PossessionCondition</h3>
    <pre><code><span class="class">PossessionCondition</span>(*args, value: Any = True)</code></pre>
    <p>Represents a condition based on an adjective's value.</p>
    <ul>
        <li>Usage:
            <ul>
                <li><code>PossessionCondition("adjective_name")</code></li>
                <li><code>PossessionCondition("pointer_adjective_name", "adjective_name")</code></li>
                <li><code>PossessionCondition("pointer_adjective_name", "adjective_name", value=some_value)</code></li>
            </ul>
        </li>
        <li><code>adjective_name</code>: The name of the adjective to check.</li>
        <li><code>pointer_adjective_name</code>: Optional. The name of the pointer adjective that selects the object to check.</li>
        <li><code>value</code>: The expected value of the adjective (default: True).</li>
    </ul>

    <h2 id="usage-example">5. Usage Example: Minimax Tree with Scoring</h2>
    <p>Here's an example of how to use the Argumentation Framework API to represent a minimax tree with scoring:</p>

    <pre><code><span class="keyword">knowledgebase</span> = <span class="class">ArgumentationFramework</span>()

<span class="comment"># Define "leaf" adjective</span>
knowledgebase.<span class="function">add_adjective</span>( 
    <span class="class">BooleanAdjective</span>(<span class="string">"leaf"</span>,
        definition = <span class="string">"node.is_leaf"</span>)
)

<span class="comment"># Define "score" adjective</span>
knowledgebase.<span class="function">add_adjective</span>( 
    <span class="class">PointerAdjective</span>(<span class="string">"score"</span>,
        definition = <span class="string">"node.score"</span>,
        explanation = <span class="class">ConditionalExplanation</span>(
            condition = <span class="class">PossessionCondition</span>(<span class="string">"leaf"</span>),
            true_explanation = <span class="class">Assumption</span>(<span class="string">"Leaf nodes have scores from the evaluation function"</span>),
            false_explanation = <span class="class">CompositeExplanation</span>(
                <span class="class">Assumption</span>(<span class="string">"Internal nodes have scores from children"</span>),
                <span class="class">Possession</span>(<span class="string">"backtracing child"</span>))
        ))
)

<span class="comment"># Define "opponent player turn" adjective</span>
knowledgebase.<span class="function">add_adjective</span>(
    <span class="class">BooleanAdjective</span>(<span class="string">"opponent player turn"</span>,
        definition = <span class="string">"not node.maximizing_player_turn"</span>)
)

<span class="comment"># Define "backtracing child" adjective</span>
knowledgebase.<span class="function">add_adjective</span>( 
    <span class="class">PointerAdjective</span>(<span class="string">"backtracing child"</span>,
        definition = <span class="string">"node.score_child"</span>,
        explanation = <span class="class">ConditionalExplanation</span>(
            condition = <span class="class">PossessionCondition</span>(<span class="string">"opponent player turn"</span>),
            true_explanation = <span class="class">CompositeExplanation</span>(
                <span class="class">Assumption</span>(<span class="string">"We assume the opponent will do their best move."</span>),
                <span class="class">Possession</span>(<span class="string">"backtracing child"</span>, <span class="string">"worst"</span>)),
            false_explanation = <span class="class">CompositeExplanation</span>(
                <span class="class">Assumption</span>(<span class="string">"On our turn we take the maximum rated move."</span>),
                <span class="class">Possession</span>(<span class="string">"backtracing child"</span>, <span class="string">"best"</span>))
        ))
)

<span class="comment"># Define "better" comparison adjective</span>
knowledgebase.<span class="function">add_adjective</span>(
    <span class="class">ComparisonAdjective</span>(<span class="string">"better"</span>, <span class="string">"score"</span>, <span class="string">">"</span